"use strict";
// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 0.12.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlogsApi = exports.BlogsApiFactory = exports.BlogsApiFp = exports.BlogsApiAxiosParamCreator = void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * BlogsApi - axios parameter creator
 * @export
 */
exports.BlogsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Detaches a category from a blog. Does not delete the category.
         * @summary Detach category
         * @param {string} blogId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCategoriesCategory: (blogId, categoryId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling deleteBlogsBlogCategoriesCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling deleteBlogsBlogCategoriesCategory.');
            }
            const localVarPath = `/blogs/{blogId}/categories/{categoryId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches a collection from a blog. Does not delete the collection.
         * @summary Detach collection
         * @param {string} blogId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCollectionsDetach: (blogId, collectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling deleteBlogsBlogCollectionsDetach.');
            }
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling deleteBlogsBlogCollectionsDetach.');
            }
            const localVarPath = `/blogs/{blogId}/collections/{collectionId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches customer groups from a blog
         * @summary Detach customer groups
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCustomerGroups: (blogId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling deleteBlogsBlogCustomerGroups.');
            }
            const localVarPath = `/blogs/{blogId}/customer-groups`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
         * @summary Delete Blog
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogId: (blogId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling deleteBlogsBlogId.');
            }
            const localVarPath = `/blogs/{blogId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes blog associations
         * @summary
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogIdAssociations: (blogId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling deleteBlogsBlogIdAssociations.');
            }
            const localVarPath = `/blogs/{blogId}/associations`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of blogs.
         * @summary Get Blogs
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogs: (include, paginated, ids, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/blogs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a blog by it\'s given ID
         * @summary Get Blog
         * @param {string} blogId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogId: (blogId, include, exclTax, fullResponse, optionData, draft, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling getBlogsBlogId.');
            }
            const localVarPath = `/blogs/{blogId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (exclTax !== undefined) {
                localVarQueryParameter['excl_tax'] = exclTax;
            }
            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }
            if (optionData !== undefined) {
                localVarQueryParameter['option_data'] = optionData;
            }
            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogIdDrafts: (blogId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling getBlogsBlogIdDrafts.');
            }
            const localVarPath = `/blogs/{blogId}/drafts`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
         * @summary Get recommended blogs
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsRecommended: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling getBlogsRecommended.');
            }
            const localVarPath = `/blogs/recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (basketId !== undefined) {
                localVarQueryParameter['basket_id'] = basketId;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog redirect
         * @param {string} blogId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogRedirects: (blogId, inlineObject19, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogRedirects.');
            }
            const localVarPath = `/blogs/{blogId}/redirects`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog route
         * @param {string} blogId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogUrls: (blogId, inlineObject18, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogUrls.');
            }
            const localVarPath = `/blogs/{blogId}/urls`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create Blog
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogs: (name, url, stock, familyId, price, sku, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new base_1.RequiredError('url', 'Required parameter url was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'stock' is not null or undefined
            if (stock === null || stock === undefined) {
                throw new base_1.RequiredError('stock', 'Required parameter stock was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'familyId' is not null or undefined
            if (familyId === null || familyId === undefined) {
                throw new base_1.RequiredError('familyId', 'Required parameter familyId was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new base_1.RequiredError('price', 'Required parameter price was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new base_1.RequiredError('sku', 'Required parameter sku was null or undefined when calling postBlogs.');
            }
            const localVarPath = `/blogs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (stock !== undefined) {
                localVarFormParams.append('stock', stock);
            }
            if (familyId !== undefined) {
                localVarFormParams.append('family_id', familyId);
            }
            if (price !== undefined) {
                localVarFormParams.append('price', price);
            }
            if (sku !== undefined) {
                localVarFormParams.append('sku', sku);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a draft blog from an existing blog.
         * @summary Create Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdDrafts: (blogId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsIdDrafts.');
            }
            const localVarPath = `/blogs/{blogId}/drafts`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Publish a draft from a Blog
         * @summary Publish Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdPublish: (blogId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsIdPublish.');
            }
            const localVarPath = `/blogs/{blogId}/publish`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates blog associations
         * @summary Update blog associations
         * @param {string} blogId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAssociations: (blogId, inlineObject24, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogAssociations.');
            }
            const localVarPath = `/blogs/{blogId}/associations`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to sync up the attributes which are directly associated to this blog.
         * @summary Update Blog attributes
         * @param {string} blogId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAttributes: (blogId, inlineObject20, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogAttributes.');
            }
            const localVarPath = `/blogs/{blogId}/attributes`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync blog categories
         * @summary Update Blog categories
         * @param {string} blogId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCategories: (blogId, inlineObject22, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogCategories.');
            }
            const localVarPath = `/blogs/{blogId}/categories`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync blog Channels
         * @summary Update Blog channels
         * @param {string} blogId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogChannels: (blogId, inlineObject23, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogChannels.');
            }
            const localVarPath = `/blogs/{blogId}/channels`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a blogs customer groups
         * @summary Update customer groups
         * @param {string} blogId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCustomerGroups: (blogId, inlineObject25, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogCustomerGroups.');
            }
            const localVarPath = `/blogs/{blogId}/customer-groups`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a blogs collections.
         * @summary Update Blog collections
         * @param {string} blogId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdCollections: (blogId, inlineObject21, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogIdCollections.');
            }
            const localVarPath = `/blogs/{blogId}/collections`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
         * @summary Duplicate Blog
         * @param {string} blogId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdDuplicate: (blogId, inlineObject17, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling postBlogsBlogIdDuplicate.');
            }
            const localVarPath = `/blogs/{blogId}/duplicate`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a blog by it\'s ID
         * @summary Update Blog
         * @param {string} blogId
         * @param {BlogUpdateBody} [blogUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogsBlogId: (blogId, blogUpdateBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new base_1.RequiredError('blogId', 'Required parameter blogId was null or undefined when calling putBlogsBlogId.');
            }
            const localVarPath = `/blogs/{blogId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof blogUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(blogUpdateBody !== undefined ? blogUpdateBody : {}) : (blogUpdateBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BlogsApi - functional programming interface
 * @export
 */
exports.BlogsApiFp = function (configuration) {
    return {
        /**
         * Detaches a category from a blog. Does not delete the category.
         * @summary Detach category
         * @param {string} blogId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCategoriesCategory(blogId, categoryId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogCategoriesCategory(blogId, categoryId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches a collection from a blog. Does not delete the collection.
         * @summary Detach collection
         * @param {string} blogId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCollectionsDetach(blogId, collectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogCollectionsDetach(blogId, collectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches customer groups from a blog
         * @summary Detach customer groups
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCustomerGroups(blogId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogCustomerGroups(blogId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
         * @summary Delete Blog
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogId(blogId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogId(blogId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Removes blog associations
         * @summary
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogIdAssociations(blogId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogIdAssociations(blogId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of blogs.
         * @summary Get Blogs
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogs(include, paginated, ids, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).getBlogs(include, paginated, ids, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a blog by it\'s given ID
         * @summary Get Blog
         * @param {string} blogId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogIdDrafts(blogId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).getBlogsBlogIdDrafts(blogId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
         * @summary Get recommended blogs
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsRecommended(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).getBlogsRecommended(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog redirect
         * @param {string} blogId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogRedirects(blogId, inlineObject19, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogRedirects(blogId, inlineObject19, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog route
         * @param {string} blogId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogUrls(blogId, inlineObject18, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogUrls(blogId, inlineObject18, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Create Blog
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogs(name, url, stock, familyId, price, sku, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogs(name, url, stock, familyId, price, sku, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a draft blog from an existing blog.
         * @summary Create Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdDrafts(blogId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsIdDrafts(blogId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Publish a draft from a Blog
         * @summary Publish Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdPublish(blogId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsIdPublish(blogId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates blog associations
         * @summary Update blog associations
         * @param {string} blogId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAssociations(blogId, inlineObject24, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogAssociations(blogId, inlineObject24, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this blog.
         * @summary Update Blog attributes
         * @param {string} blogId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAttributes(blogId, inlineObject20, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogAttributes(blogId, inlineObject20, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync blog categories
         * @summary Update Blog categories
         * @param {string} blogId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCategories(blogId, inlineObject22, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogCategories(blogId, inlineObject22, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync blog Channels
         * @summary Update Blog channels
         * @param {string} blogId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogChannels(blogId, inlineObject23, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogChannels(blogId, inlineObject23, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a blogs customer groups
         * @summary Update customer groups
         * @param {string} blogId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCustomerGroups(blogId, inlineObject25, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogCustomerGroups(blogId, inlineObject25, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a blogs collections.
         * @summary Update Blog collections
         * @param {string} blogId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdCollections(blogId, inlineObject21, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogIdCollections(blogId, inlineObject21, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
         * @summary Duplicate Blog
         * @param {string} blogId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdDuplicate(blogId, inlineObject17, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).postBlogsBlogIdDuplicate(blogId, inlineObject17, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a blog by it\'s ID
         * @summary Update Blog
         * @param {string} blogId
         * @param {BlogUpdateBody} [blogUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogsBlogId(blogId, blogUpdateBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BlogsApiAxiosParamCreator(configuration).putBlogsBlogId(blogId, blogUpdateBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * BlogsApi - factory interface
 * @export
 */
exports.BlogsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Detaches a category from a blog. Does not delete the category.
         * @summary Detach category
         * @param {string} blogId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCategoriesCategory(blogId, categoryId, options) {
            return exports.BlogsApiFp(configuration).deleteBlogsBlogCategoriesCategory(blogId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a collection from a blog. Does not delete the collection.
         * @summary Detach collection
         * @param {string} blogId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCollectionsDetach(blogId, collectionId, options) {
            return exports.BlogsApiFp(configuration).deleteBlogsBlogCollectionsDetach(blogId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches customer groups from a blog
         * @summary Detach customer groups
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCustomerGroups(blogId, options) {
            return exports.BlogsApiFp(configuration).deleteBlogsBlogCustomerGroups(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
         * @summary Delete Blog
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogId(blogId, options) {
            return exports.BlogsApiFp(configuration).deleteBlogsBlogId(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes blog associations
         * @summary
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogIdAssociations(blogId, options) {
            return exports.BlogsApiFp(configuration).deleteBlogsBlogIdAssociations(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of blogs.
         * @summary Get Blogs
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogs(include, paginated, ids, limit, options) {
            return exports.BlogsApiFp(configuration).getBlogs(include, paginated, ids, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a blog by it\'s given ID
         * @summary Get Blog
         * @param {string} blogId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options) {
            return exports.BlogsApiFp(configuration).getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogIdDrafts(blogId, options) {
            return exports.BlogsApiFp(configuration).getBlogsBlogIdDrafts(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
         * @summary Get recommended blogs
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsRecommended(basketId, options) {
            return exports.BlogsApiFp(configuration).getBlogsRecommended(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog redirect
         * @param {string} blogId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogRedirects(blogId, inlineObject19, options) {
            return exports.BlogsApiFp(configuration).postBlogRedirects(blogId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog route
         * @param {string} blogId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogUrls(blogId, inlineObject18, options) {
            return exports.BlogsApiFp(configuration).postBlogUrls(blogId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Blog
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogs(name, url, stock, familyId, price, sku, include, options) {
            return exports.BlogsApiFp(configuration).postBlogs(name, url, stock, familyId, price, sku, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft blog from an existing blog.
         * @summary Create Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdDrafts(blogId, options) {
            return exports.BlogsApiFp(configuration).postBlogsIdDrafts(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a draft from a Blog
         * @summary Publish Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdPublish(blogId, options) {
            return exports.BlogsApiFp(configuration).postBlogsIdPublish(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates blog associations
         * @summary Update blog associations
         * @param {string} blogId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAssociations(blogId, inlineObject24, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogAssociations(blogId, inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this blog.
         * @summary Update Blog attributes
         * @param {string} blogId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAttributes(blogId, inlineObject20, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogAttributes(blogId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync blog categories
         * @summary Update Blog categories
         * @param {string} blogId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCategories(blogId, inlineObject22, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogCategories(blogId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync blog Channels
         * @summary Update Blog channels
         * @param {string} blogId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogChannels(blogId, inlineObject23, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogChannels(blogId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a blogs customer groups
         * @summary Update customer groups
         * @param {string} blogId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCustomerGroups(blogId, inlineObject25, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogCustomerGroups(blogId, inlineObject25, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a blogs collections.
         * @summary Update Blog collections
         * @param {string} blogId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdCollections(blogId, inlineObject21, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogIdCollections(blogId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
         * @summary Duplicate Blog
         * @param {string} blogId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdDuplicate(blogId, inlineObject17, options) {
            return exports.BlogsApiFp(configuration).postBlogsBlogIdDuplicate(blogId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a blog by it\'s ID
         * @summary Update Blog
         * @param {string} blogId
         * @param {BlogUpdateBody} [blogUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogsBlogId(blogId, blogUpdateBody, options) {
            return exports.BlogsApiFp(configuration).putBlogsBlogId(blogId, blogUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
class BlogsApi extends base_1.BaseAPI {
    /**
     * Detaches a category from a blog. Does not delete the category.
     * @summary Detach category
     * @param {string} blogId
     * @param {string} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    deleteBlogsBlogCategoriesCategory(blogId, categoryId, options) {
        return exports.BlogsApiFp(this.configuration).deleteBlogsBlogCategoriesCategory(blogId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches a collection from a blog. Does not delete the collection.
     * @summary Detach collection
     * @param {string} blogId
     * @param {string} collectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    deleteBlogsBlogCollectionsDetach(blogId, collectionId, options) {
        return exports.BlogsApiFp(this.configuration).deleteBlogsBlogCollectionsDetach(blogId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches customer groups from a blog
     * @summary Detach customer groups
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    deleteBlogsBlogCustomerGroups(blogId, options) {
        return exports.BlogsApiFp(this.configuration).deleteBlogsBlogCustomerGroups(blogId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
     * @summary Delete Blog
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    deleteBlogsBlogId(blogId, options) {
        return exports.BlogsApiFp(this.configuration).deleteBlogsBlogId(blogId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes blog associations
     * @summary
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    deleteBlogsBlogIdAssociations(blogId, options) {
        return exports.BlogsApiFp(this.configuration).deleteBlogsBlogIdAssociations(blogId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of blogs.
     * @summary Get Blogs
     * @param {string} [include]
     * @param {boolean} [paginated]
     * @param {string} [ids] Return only the selected IDs
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    getBlogs(include, paginated, ids, limit, options) {
        return exports.BlogsApiFp(this.configuration).getBlogs(include, paginated, ids, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a blog by it\'s given ID
     * @summary Get Blog
     * @param {string} blogId
     * @param {string} [include]
     * @param {string} [exclTax] Prices shouldn\&#39;t include tax
     * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
     * @param {string} [optionData] Include option data
     * @param {string} [draft] Show draft if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options) {
        return exports.BlogsApiFp(this.configuration).getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
     * @summary Create draft
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    getBlogsBlogIdDrafts(blogId, options) {
        return exports.BlogsApiFp(this.configuration).getBlogsBlogIdDrafts(blogId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
     * @summary Get recommended blogs
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    getBlogsRecommended(basketId, options) {
        return exports.BlogsApiFp(this.configuration).getBlogsRecommended(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and syncs a new blog route.
     * @summary Create Blog redirect
     * @param {string} blogId
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogRedirects(blogId, inlineObject19, options) {
        return exports.BlogsApiFp(this.configuration).postBlogRedirects(blogId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and syncs a new blog route.
     * @summary Create Blog route
     * @param {string} blogId
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogUrls(blogId, inlineObject18, options) {
        return exports.BlogsApiFp(this.configuration).postBlogUrls(blogId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Blog
     * @param {ShippingShippingMethodIdName} name
     * @param {string} url
     * @param {number} stock
     * @param {string} familyId
     * @param {number} price
     * @param {string} sku
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogs(name, url, stock, familyId, price, sku, include, options) {
        return exports.BlogsApiFp(this.configuration).postBlogs(name, url, stock, familyId, price, sku, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a draft blog from an existing blog.
     * @summary Create Draft
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsIdDrafts(blogId, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsIdDrafts(blogId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publish a draft from a Blog
     * @summary Publish Draft
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsIdPublish(blogId, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsIdPublish(blogId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates blog associations
     * @summary Update blog associations
     * @param {string} blogId
     * @param {InlineObject24} [inlineObject24]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogAssociations(blogId, inlineObject24, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogAssociations(blogId, inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to sync up the attributes which are directly associated to this blog.
     * @summary Update Blog attributes
     * @param {string} blogId
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogAttributes(blogId, inlineObject20, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogAttributes(blogId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync blog categories
     * @summary Update Blog categories
     * @param {string} blogId
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogCategories(blogId, inlineObject22, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogCategories(blogId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync blog Channels
     * @summary Update Blog channels
     * @param {string} blogId
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogChannels(blogId, inlineObject23, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogChannels(blogId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a blogs customer groups
     * @summary Update customer groups
     * @param {string} blogId
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogCustomerGroups(blogId, inlineObject25, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogCustomerGroups(blogId, inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a blogs collections.
     * @summary Update Blog collections
     * @param {string} blogId
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogIdCollections(blogId, inlineObject21, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogIdCollections(blogId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
     * @summary Duplicate Blog
     * @param {string} blogId
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    postBlogsBlogIdDuplicate(blogId, inlineObject17, options) {
        return exports.BlogsApiFp(this.configuration).postBlogsBlogIdDuplicate(blogId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a blog by it\'s ID
     * @summary Update Blog
     * @param {string} blogId
     * @param {BlogUpdateBody} [blogUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    putBlogsBlogId(blogId, blogUpdateBody, options) {
        return exports.BlogsApiFp(this.configuration).putBlogsBlogId(blogId, blogUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BlogsApi = BlogsApi;
