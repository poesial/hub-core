"use strict";
// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 0.12.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
/**
 * ProductsApi - axios parameter creator
 * @export
 */
exports.ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory: (productId, categoryId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            const localVarPath = `/products/{productId}/categories/{categoryId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach: (productId, collectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            const localVarPath = `/products/{productId}/collections/{collectionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductIdAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: (include, paginated, ids, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId: (productId, include, exclTax, fullResponse, optionData, draft, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling getProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (exclTax !== undefined) {
                localVarQueryParameter['excl_tax'] = exclTax;
            }
            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }
            if (optionData !== undefined) {
                localVarQueryParameter['option_data'] = optionData;
            }
            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling getProductsProductIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling getProductsRecommended.');
            }
            const localVarPath = `/products/recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (basketId !== undefined) {
                localVarQueryParameter['basket_id'] = basketId;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects: (productId, inlineObject19, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductRedirects.');
            }
            const localVarPath = `/products/{productId}/redirects`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls: (productId, inlineObject18, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductUrls.');
            }
            const localVarPath = `/products/{productId}/urls`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts: (name, url, stock, familyId, price, sku, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling postProducts.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new base_1.RequiredError('url', 'Required parameter url was null or undefined when calling postProducts.');
            }
            // verify required parameter 'stock' is not null or undefined
            if (stock === null || stock === undefined) {
                throw new base_1.RequiredError('stock', 'Required parameter stock was null or undefined when calling postProducts.');
            }
            // verify required parameter 'familyId' is not null or undefined
            if (familyId === null || familyId === undefined) {
                throw new base_1.RequiredError('familyId', 'Required parameter familyId was null or undefined when calling postProducts.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new base_1.RequiredError('price', 'Required parameter price was null or undefined when calling postProducts.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new base_1.RequiredError('sku', 'Required parameter sku was null or undefined when calling postProducts.');
            }
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (stock !== undefined) {
                localVarFormParams.append('stock', stock);
            }
            if (familyId !== undefined) {
                localVarFormParams.append('family_id', familyId);
            }
            if (price !== undefined) {
                localVarFormParams.append('price', price);
            }
            if (sku !== undefined) {
                localVarFormParams.append('sku', sku);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsIdPublish.');
            }
            const localVarPath = `/products/{productId}/publish`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations: (productId, inlineObject24, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes: (productId, inlineObject20, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductAttributes.');
            }
            const localVarPath = `/products/{productId}/attributes`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories: (productId, inlineObject22, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductCategories.');
            }
            const localVarPath = `/products/{productId}/categories`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels: (productId, inlineObject23, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductChannels.');
            }
            const localVarPath = `/products/{productId}/channels`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups: (productId, inlineObject25, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections: (productId, inlineObject21, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductIdCollections.');
            }
            const localVarPath = `/products/{productId}/collections`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate: (productId, inlineObject17, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductIdDuplicate.');
            }
            const localVarPath = `/products/{productId}/duplicate`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId: (productId, productUpdateBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling putProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof productUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(productUpdateBody !== undefined ? productUpdateBody : {}) : (productUpdateBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
exports.ProductsApiFp = function (configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory(productId, categoryId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach(productId, collectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductCustomerGroups(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductId(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductIdAssociations(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(include, paginated, ids, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProducts(include, paginated, ids, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductsProductIdDrafts(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductsRecommended(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects(productId, inlineObject19, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductRedirects(productId, inlineObject19, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls(productId, inlineObject18, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductUrls(productId, inlineObject18, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(name, url, stock, familyId, price, sku, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProducts(name, url, stock, familyId, price, sku, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsIdDrafts(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsIdPublish(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations(productId, inlineObject24, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductAssociations(productId, inlineObject24, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes(productId, inlineObject20, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductAttributes(productId, inlineObject20, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories(productId, inlineObject22, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductCategories(productId, inlineObject22, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels(productId, inlineObject23, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductChannels(productId, inlineObject23, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups(productId, inlineObject25, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductCustomerGroups(productId, inlineObject25, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections(productId, inlineObject21, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductIdCollections(productId, inlineObject21, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate(productId, inlineObject17, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductIdDuplicate(productId, inlineObject17, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId(productId, productUpdateBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).putProductsProductId(productId, productUpdateBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProductsApi - factory interface
 * @export
 */
exports.ProductsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory(productId, categoryId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach(productId, collectionId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductId(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(include, paginated, ids, limit, options) {
            return exports.ProductsApiFp(configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options) {
            return exports.ProductsApiFp(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts(productId, options) {
            return exports.ProductsApiFp(configuration).getProductsProductIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended(basketId, options) {
            return exports.ProductsApiFp(configuration).getProductsRecommended(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects(productId, inlineObject19, options) {
            return exports.ProductsApiFp(configuration).postProductRedirects(productId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls(productId, inlineObject18, options) {
            return exports.ProductsApiFp(configuration).postProductUrls(productId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(name, url, stock, familyId, price, sku, include, options) {
            return exports.ProductsApiFp(configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts(productId, options) {
            return exports.ProductsApiFp(configuration).postProductsIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish(productId, options) {
            return exports.ProductsApiFp(configuration).postProductsIdPublish(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations(productId, inlineObject24, options) {
            return exports.ProductsApiFp(configuration).postProductsProductAssociations(productId, inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes(productId, inlineObject20, options) {
            return exports.ProductsApiFp(configuration).postProductsProductAttributes(productId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories(productId, inlineObject22, options) {
            return exports.ProductsApiFp(configuration).postProductsProductCategories(productId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels(productId, inlineObject23, options) {
            return exports.ProductsApiFp(configuration).postProductsProductChannels(productId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups(productId, inlineObject25, options) {
            return exports.ProductsApiFp(configuration).postProductsProductCustomerGroups(productId, inlineObject25, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections(productId, inlineObject21, options) {
            return exports.ProductsApiFp(configuration).postProductsProductIdCollections(productId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate(productId, inlineObject17, options) {
            return exports.ProductsApiFp(configuration).postProductsProductIdDuplicate(productId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId(productId, productUpdateBody, options) {
            return exports.ProductsApiFp(configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     * Detaches a category from a product. Does not delete the category.
     * @summary Detach category
     * @param {string} productId
     * @param {string} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductCategoriesCategory(productId, categoryId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches a collection from a product. Does not delete the collection.
     * @summary Detach collection
     * @param {string} productId
     * @param {string} collectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductCollectionsDetach(productId, collectionId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches customer groups from a product
     * @summary Detach customer groups
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductCustomerGroups(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
     * @summary Delete Product
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductId(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductId(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes product associations
     * @summary
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductIdAssociations(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of products.
     * @summary Get Products
     * @param {string} [include]
     * @param {boolean} [paginated]
     * @param {string} [ids] Return only the selected IDs
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProducts(include, paginated, ids, limit, options) {
        return exports.ProductsApiFp(this.configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a product by it\'s given ID
     * @summary Get Product
     * @param {string} productId
     * @param {string} [include]
     * @param {string} [exclTax] Prices shouldn\&#39;t include tax
     * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
     * @param {string} [optionData] Include option data
     * @param {string} [draft] Show draft if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options) {
        return exports.ProductsApiFp(this.configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a draft for a product.  If a draft already exists, that current draft will be returned.
     * @summary Create draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductsProductIdDrafts(productId, options) {
        return exports.ProductsApiFp(this.configuration).getProductsProductIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
     * @summary Get recommended products
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductsRecommended(basketId, options) {
        return exports.ProductsApiFp(this.configuration).getProductsRecommended(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and syncs a new product route.
     * @summary Create Product redirect
     * @param {string} productId
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductRedirects(productId, inlineObject19, options) {
        return exports.ProductsApiFp(this.configuration).postProductRedirects(productId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and syncs a new product route.
     * @summary Create Product route
     * @param {string} productId
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductUrls(productId, inlineObject18, options) {
        return exports.ProductsApiFp(this.configuration).postProductUrls(productId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Product
     * @param {ShippingShippingMethodIdName} name
     * @param {string} url
     * @param {number} stock
     * @param {string} familyId
     * @param {number} price
     * @param {string} sku
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProducts(name, url, stock, familyId, price, sku, include, options) {
        return exports.ProductsApiFp(this.configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a draft product from an existing product.
     * @summary Create Draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsIdDrafts(productId, options) {
        return exports.ProductsApiFp(this.configuration).postProductsIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publish a draft from a Product
     * @summary Publish Draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsIdPublish(productId, options) {
        return exports.ProductsApiFp(this.configuration).postProductsIdPublish(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates product associations
     * @summary Update product associations
     * @param {string} productId
     * @param {InlineObject24} [inlineObject24]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductAssociations(productId, inlineObject24, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductAssociations(productId, inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to sync up the attributes which are directly associated to this product.
     * @summary Update Product attributes
     * @param {string} productId
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductAttributes(productId, inlineObject20, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductAttributes(productId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync product categories
     * @summary Update Product categories
     * @param {string} productId
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductCategories(productId, inlineObject22, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductCategories(productId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync product Channels
     * @summary Update Product channels
     * @param {string} productId
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductChannels(productId, inlineObject23, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductChannels(productId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a products customer groups
     * @summary Update customer groups
     * @param {string} productId
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductCustomerGroups(productId, inlineObject25, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductCustomerGroups(productId, inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a products collections.
     * @summary Update Product collections
     * @param {string} productId
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductIdCollections(productId, inlineObject21, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductIdCollections(productId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
     * @summary Duplicate Product
     * @param {string} productId
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductIdDuplicate(productId, inlineObject17, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductIdDuplicate(productId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a product by it\'s ID
     * @summary Update Product
     * @param {string} productId
     * @param {ProductUpdateBody} [productUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    putProductsProductId(productId, productUpdateBody, options) {
        return exports.ProductsApiFp(this.configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
