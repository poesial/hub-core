// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 0.12.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiError } from '../models';
// @ts-ignore
import { InlineObject17 } from '../models';
// @ts-ignore
import { InlineObject18 } from '../models';
// @ts-ignore
import { InlineObject19 } from '../models';
// @ts-ignore
import { InlineObject20 } from '../models';
// @ts-ignore
import { InlineObject21 } from '../models';
// @ts-ignore
import { InlineObject22 } from '../models';
// @ts-ignore
import { InlineObject23 } from '../models';
// @ts-ignore
import { InlineObject24 } from '../models';
// @ts-ignore
import { InlineObject25 } from '../models';
// @ts-ignore
import { InlineResponse4226 } from '../models';
// @ts-ignore
import { InlineResponse4227 } from '../models';
// @ts-ignore
import { ProductCollection } from '../models';
// @ts-ignore
import { ProductRecommendationCollection } from '../models';
// @ts-ignore
import { ProductResponse } from '../models';
// @ts-ignore
import { ProductUpdateBody } from '../models';
// @ts-ignore
import { ShippingShippingMethodIdName } from '../models';
// @ts-ignore
import { Unauthenticated } from '../models';
/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory: async (productId: string, categoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            const localVarPath = `/products/{productId}/categories/{categoryId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach: async (productId: string, collectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            const localVarPath = `/products/{productId}/collections/{collectionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductIdAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (include?: string, paginated?: boolean, ids?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId: async (productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (exclTax !== undefined) {
                localVarQueryParameter['excl_tax'] = exclTax;
            }

            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }

            if (optionData !== undefined) {
                localVarQueryParameter['option_data'] = optionData;
            }

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductsProductIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling getProductsRecommended.');
            }
            const localVarPath = `/products/recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (basketId !== undefined) {
                localVarQueryParameter['basket_id'] = basketId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects: async (productId: string, inlineObject19?: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductRedirects.');
            }
            const localVarPath = `/products/{productId}/redirects`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls: async (productId: string, inlineObject18?: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductUrls.');
            }
            const localVarPath = `/products/{productId}/urls`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts: async (name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postProducts.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling postProducts.');
            }
            // verify required parameter 'stock' is not null or undefined
            if (stock === null || stock === undefined) {
                throw new RequiredError('stock','Required parameter stock was null or undefined when calling postProducts.');
            }
            // verify required parameter 'familyId' is not null or undefined
            if (familyId === null || familyId === undefined) {
                throw new RequiredError('familyId','Required parameter familyId was null or undefined when calling postProducts.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new RequiredError('price','Required parameter price was null or undefined when calling postProducts.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling postProducts.');
            }
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


            if (name !== undefined) {
                localVarFormParams.append('name', name as any);
            }

            if (url !== undefined) {
                localVarFormParams.append('url', url as any);
            }

            if (stock !== undefined) {
                localVarFormParams.append('stock', stock as any);
            }

            if (familyId !== undefined) {
                localVarFormParams.append('family_id', familyId as any);
            }

            if (price !== undefined) {
                localVarFormParams.append('price', price as any);
            }

            if (sku !== undefined) {
                localVarFormParams.append('sku', sku as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsIdPublish.');
            }
            const localVarPath = `/products/{productId}/publish`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations: async (productId: string, inlineObject24?: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes: async (productId: string, inlineObject20?: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductAttributes.');
            }
            const localVarPath = `/products/{productId}/attributes`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories: async (productId: string, inlineObject22?: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductCategories.');
            }
            const localVarPath = `/products/{productId}/categories`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels: async (productId: string, inlineObject23?: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductChannels.');
            }
            const localVarPath = `/products/{productId}/channels`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups: async (productId: string, inlineObject25?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections: async (productId: string, inlineObject21?: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductIdCollections.');
            }
            const localVarPath = `/products/{productId}/collections`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate: async (productId: string, inlineObject17?: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductIdDuplicate.');
            }
            const localVarPath = `/products/{productId}/duplicate`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId: async (productId: string, productUpdateBody?: ProductUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling putProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productUpdateBody !== undefined ? productUpdateBody : {}) : (productUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductCategoriesCategory(productId: string, categoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductCollectionsDetach(productId: string, collectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductCustomerGroups(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductCustomerGroups(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductId(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductId(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductIdAssociations(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductIdAssociations(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCollection>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProducts(include, paginated, ids, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsProductId(productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsProductIdDrafts(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductsProductIdDrafts(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsRecommended(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductRecommendationCollection>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductsRecommended(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductRedirects(productId: string, inlineObject19?: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductRedirects(productId, inlineObject19, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductUrls(productId: string, inlineObject18?: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductUrls(productId, inlineObject18, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProducts(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProducts(name, url, stock, familyId, price, sku, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsIdDrafts(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsIdDrafts(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsIdPublish(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsIdPublish(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductAssociations(productId: string, inlineObject24?: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductAssociations(productId, inlineObject24, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductAttributes(productId: string, inlineObject20?: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductAttributes(productId, inlineObject20, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductCategories(productId: string, inlineObject22?: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductCategories(productId, inlineObject22, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductChannels(productId: string, inlineObject23?: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductChannels(productId, inlineObject23, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductCustomerGroups(productId: string, inlineObject25?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductCustomerGroups(productId, inlineObject25, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductIdCollections(productId: string, inlineObject21?: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductIdCollections(productId, inlineObject21, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductIdDuplicate(productId: string, inlineObject17?: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductIdDuplicate(productId, inlineObject17, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProductsProductId(productId: string, productUpdateBody?: ProductUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).putProductsProductId(productId, productUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory(productId: string, categoryId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach(productId: string, collectionId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups(productId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId(productId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductId(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations(productId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any): AxiosPromise<ProductCollection> {
            return ProductsApiFp(configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId(productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts(productId: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).getProductsProductIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended(basketId: string, options?: any): AxiosPromise<ProductRecommendationCollection> {
            return ProductsApiFp(configuration).getProductsRecommended(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects(productId: string, inlineObject19?: InlineObject19, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductRedirects(productId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls(productId: string, inlineObject18?: InlineObject18, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductUrls(productId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts(productId: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish(productId: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsIdPublish(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations(productId: string, inlineObject24?: InlineObject24, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductAssociations(productId, inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes(productId: string, inlineObject20?: InlineObject20, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductAttributes(productId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories(productId: string, inlineObject22?: InlineObject22, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductCategories(productId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels(productId: string, inlineObject23?: InlineObject23, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductChannels(productId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups(productId: string, inlineObject25?: InlineObject25, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductCustomerGroups(productId, inlineObject25, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections(productId: string, inlineObject21?: InlineObject21, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductIdCollections(productId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate(productId: string, inlineObject17?: InlineObject17, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductIdDuplicate(productId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId(productId: string, productUpdateBody?: ProductUpdateBody, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Detaches a category from a product. Does not delete the category.
     * @summary Detach category
     * @param {string} productId
     * @param {string} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductCategoriesCategory(productId: string, categoryId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches a collection from a product. Does not delete the collection.
     * @summary Detach collection
     * @param {string} productId
     * @param {string} collectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductCollectionsDetach(productId: string, collectionId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches customer groups from a product
     * @summary Detach customer groups
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductCustomerGroups(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
     * @summary Delete Product
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductId(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductId(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes product associations
     * @summary
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductIdAssociations(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of products.
     * @summary Get Products
     * @param {string} [include]
     * @param {boolean} [paginated]
     * @param {string} [ids] Return only the selected IDs
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any) {
        return ProductsApiFp(this.configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a product by it\'s given ID
     * @summary Get Product
     * @param {string} productId
     * @param {string} [include]
     * @param {string} [exclTax] Prices shouldn\&#39;t include tax
     * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
     * @param {string} [optionData] Include option data
     * @param {string} [draft] Show draft if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsProductId(productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft for a product.  If a draft already exists, that current draft will be returned.
     * @summary Create draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsProductIdDrafts(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductsProductIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
     * @summary Get recommended products
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsRecommended(basketId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductsRecommended(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and syncs a new product route.
     * @summary Create Product redirect
     * @param {string} productId
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductRedirects(productId: string, inlineObject19?: InlineObject19, options?: any) {
        return ProductsApiFp(this.configuration).postProductRedirects(productId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and syncs a new product route.
     * @summary Create Product route
     * @param {string} productId
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductUrls(productId: string, inlineObject18?: InlineObject18, options?: any) {
        return ProductsApiFp(this.configuration).postProductUrls(productId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create Product
     * @param {ShippingShippingMethodIdName} name
     * @param {string} url
     * @param {number} stock
     * @param {string} familyId
     * @param {number} price
     * @param {string} sku
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProducts(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any) {
        return ProductsApiFp(this.configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft product from an existing product.
     * @summary Create Draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsIdDrafts(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).postProductsIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish a draft from a Product
     * @summary Publish Draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsIdPublish(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).postProductsIdPublish(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates product associations
     * @summary Update product associations
     * @param {string} productId
     * @param {InlineObject24} [inlineObject24]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductAssociations(productId: string, inlineObject24?: InlineObject24, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductAssociations(productId, inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to sync up the attributes which are directly associated to this product.
     * @summary Update Product attributes
     * @param {string} productId
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductAttributes(productId: string, inlineObject20?: InlineObject20, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductAttributes(productId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync product categories
     * @summary Update Product categories
     * @param {string} productId
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductCategories(productId: string, inlineObject22?: InlineObject22, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductCategories(productId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync product Channels
     * @summary Update Product channels
     * @param {string} productId
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductChannels(productId: string, inlineObject23?: InlineObject23, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductChannels(productId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a products customer groups
     * @summary Update customer groups
     * @param {string} productId
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductCustomerGroups(productId: string, inlineObject25?: InlineObject25, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductCustomerGroups(productId, inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a products collections.
     * @summary Update Product collections
     * @param {string} productId
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductIdCollections(productId: string, inlineObject21?: InlineObject21, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductIdCollections(productId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
     * @summary Duplicate Product
     * @param {string} productId
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductIdDuplicate(productId: string, inlineObject17?: InlineObject17, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductIdDuplicate(productId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a product by it\'s ID
     * @summary Update Product
     * @param {string} productId
     * @param {ProductUpdateBody} [productUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public putProductsProductId(productId: string, productUpdateBody?: ProductUpdateBody, options?: any) {
        return ProductsApiFp(this.configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

}
