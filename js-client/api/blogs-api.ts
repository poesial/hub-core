// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 0.12.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiError } from '../models';
// @ts-ignore
import { InlineObject17 } from '../models';
// @ts-ignore
import { InlineObject18 } from '../models';
// @ts-ignore
import { InlineObject19 } from '../models';
// @ts-ignore
import { InlineObject20 } from '../models';
// @ts-ignore
import { InlineObject21 } from '../models';
// @ts-ignore
import { InlineObject22 } from '../models';
// @ts-ignore
import { InlineObject23 } from '../models';
// @ts-ignore
import { InlineObject24 } from '../models';
// @ts-ignore
import { InlineObject25 } from '../models';
// @ts-ignore
import { InlineResponse4226 } from '../models';
// @ts-ignore
import { InlineResponse4227 } from '../models';
// @ts-ignore
import { BlogCollection } from '../models';
// @ts-ignore
import { BlogRecommendationCollection } from '../models';
// @ts-ignore
import { BlogResponse } from '../models';
// @ts-ignore
import { BlogUpdateBody } from '../models';
// @ts-ignore
import { ShippingShippingMethodIdName } from '../models';
// @ts-ignore
import { Unauthenticated } from '../models';
/**
 * BlogsApi - axios parameter creator
 * @export
 */
export const BlogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detaches a category from a blog. Does not delete the category.
         * @summary Detach category
         * @param {string} blogId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCategoriesCategory: async (blogId: string, categoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling deleteBlogsBlogCategoriesCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteBlogsBlogCategoriesCategory.');
            }
            const localVarPath = `/blogs/{blogId}/categories/{categoryId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches a collection from a blog. Does not delete the collection.
         * @summary Detach collection
         * @param {string} blogId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCollectionsDetach: async (blogId: string, collectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling deleteBlogsBlogCollectionsDetach.');
            }
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling deleteBlogsBlogCollectionsDetach.');
            }
            const localVarPath = `/blogs/{blogId}/collections/{collectionId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches customer groups from a blog
         * @summary Detach customer groups
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCustomerGroups: async (blogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling deleteBlogsBlogCustomerGroups.');
            }
            const localVarPath = `/blogs/{blogId}/customer-groups`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
         * @summary Delete Blog
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogId: async (blogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling deleteBlogsBlogId.');
            }
            const localVarPath = `/blogs/{blogId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes blog associations
         * @summary
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogIdAssociations: async (blogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling deleteBlogsBlogIdAssociations.');
            }
            const localVarPath = `/blogs/{blogId}/associations`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of blogs.
         * @summary Get Blogs
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogs: async (include?: string, paginated?: boolean, ids?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/blogs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a blog by it\'s given ID
         * @summary Get Blog
         * @param {string} blogId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogId: async (blogId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlogsBlogId.');
            }
            const localVarPath = `/blogs/{blogId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (exclTax !== undefined) {
                localVarQueryParameter['excl_tax'] = exclTax;
            }

            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }

            if (optionData !== undefined) {
                localVarQueryParameter['option_data'] = optionData;
            }

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogIdDrafts: async (blogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling getBlogsBlogIdDrafts.');
            }
            const localVarPath = `/blogs/{blogId}/drafts`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
         * @summary Get recommended blogs
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsRecommended: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling getBlogsRecommended.');
            }
            const localVarPath = `/blogs/recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (basketId !== undefined) {
                localVarQueryParameter['basket_id'] = basketId;
            }



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog redirect
         * @param {string} blogId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogRedirects: async (blogId: string, inlineObject19?: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogRedirects.');
            }
            const localVarPath = `/blogs/{blogId}/redirects`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog route
         * @param {string} blogId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogUrls: async (blogId: string, inlineObject18?: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogUrls.');
            }
            const localVarPath = `/blogs/{blogId}/urls`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Blog
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogs: async (name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'stock' is not null or undefined
            if (stock === null || stock === undefined) {
                throw new RequiredError('stock','Required parameter stock was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'familyId' is not null or undefined
            if (familyId === null || familyId === undefined) {
                throw new RequiredError('familyId','Required parameter familyId was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new RequiredError('price','Required parameter price was null or undefined when calling postBlogs.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling postBlogs.');
            }
            const localVarPath = `/blogs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


            if (name !== undefined) {
                localVarFormParams.append('name', name as any);
            }

            if (url !== undefined) {
                localVarFormParams.append('url', url as any);
            }

            if (stock !== undefined) {
                localVarFormParams.append('stock', stock as any);
            }

            if (familyId !== undefined) {
                localVarFormParams.append('family_id', familyId as any);
            }

            if (price !== undefined) {
                localVarFormParams.append('price', price as any);
            }

            if (sku !== undefined) {
                localVarFormParams.append('sku', sku as any);
            }


            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft blog from an existing blog.
         * @summary Create Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdDrafts: async (blogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsIdDrafts.');
            }
            const localVarPath = `/blogs/{blogId}/drafts`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish a draft from a Blog
         * @summary Publish Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdPublish: async (blogId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsIdPublish.');
            }
            const localVarPath = `/blogs/{blogId}/publish`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates blog associations
         * @summary Update blog associations
         * @param {string} blogId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAssociations: async (blogId: string, inlineObject24?: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogAssociations.');
            }
            const localVarPath = `/blogs/{blogId}/associations`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this blog.
         * @summary Update Blog attributes
         * @param {string} blogId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAttributes: async (blogId: string, inlineObject20?: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogAttributes.');
            }
            const localVarPath = `/blogs/{blogId}/attributes`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync blog categories
         * @summary Update Blog categories
         * @param {string} blogId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCategories: async (blogId: string, inlineObject22?: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogCategories.');
            }
            const localVarPath = `/blogs/{blogId}/categories`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync blog Channels
         * @summary Update Blog channels
         * @param {string} blogId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogChannels: async (blogId: string, inlineObject23?: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogChannels.');
            }
            const localVarPath = `/blogs/{blogId}/channels`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a blogs customer groups
         * @summary Update customer groups
         * @param {string} blogId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCustomerGroups: async (blogId: string, inlineObject25?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogCustomerGroups.');
            }
            const localVarPath = `/blogs/{blogId}/customer-groups`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a blogs collections.
         * @summary Update Blog collections
         * @param {string} blogId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdCollections: async (blogId: string, inlineObject21?: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogIdCollections.');
            }
            const localVarPath = `/blogs/{blogId}/collections`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
         * @summary Duplicate Blog
         * @param {string} blogId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdDuplicate: async (blogId: string, inlineObject17?: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling postBlogsBlogIdDuplicate.');
            }
            const localVarPath = `/blogs/{blogId}/duplicate`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a blog by it\'s ID
         * @summary Update Blog
         * @param {string} blogId
         * @param {BlogUpdateBody} [blogUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogsBlogId: async (blogId: string, blogUpdateBody?: BlogUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blogId' is not null or undefined
            if (blogId === null || blogId === undefined) {
                throw new RequiredError('blogId','Required parameter blogId was null or undefined when calling putBlogsBlogId.');
            }
            const localVarPath = `/blogs/{blogId}`
                .replace(`{${"blogId"}}`, encodeURIComponent(String(blogId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof blogUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(blogUpdateBody !== undefined ? blogUpdateBody : {}) : (blogUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlogsApi - functional programming interface
 * @export
 */
export const BlogsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detaches a category from a blog. Does not delete the category.
         * @summary Detach category
         * @param {string} blogId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogsBlogCategoriesCategory(blogId: string, categoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogCategoriesCategory(blogId, categoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches a collection from a blog. Does not delete the collection.
         * @summary Detach collection
         * @param {string} blogId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogsBlogCollectionsDetach(blogId: string, collectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogCollectionsDetach(blogId, collectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches customer groups from a blog
         * @summary Detach customer groups
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogsBlogCustomerGroups(blogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogCustomerGroups(blogId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
         * @summary Delete Blog
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogsBlogId(blogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogId(blogId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes blog associations
         * @summary
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlogsBlogIdAssociations(blogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).deleteBlogsBlogIdAssociations(blogId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of blogs.
         * @summary Get Blogs
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogs(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogCollection>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).getBlogs(include, paginated, ids, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a blog by it\'s given ID
         * @summary Get Blog
         * @param {string} blogId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogsBlogId(blogId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogsBlogIdDrafts(blogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).getBlogsBlogIdDrafts(blogId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
         * @summary Get recommended blogs
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlogsRecommended(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogRecommendationCollection>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).getBlogsRecommended(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog redirect
         * @param {string} blogId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogRedirects(blogId: string, inlineObject19?: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogRedirects(blogId, inlineObject19, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog route
         * @param {string} blogId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogUrls(blogId: string, inlineObject18?: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogUrls(blogId, inlineObject18, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create Blog
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogs(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogs(name, url, stock, familyId, price, sku, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a draft blog from an existing blog.
         * @summary Create Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsIdDrafts(blogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsIdDrafts(blogId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Publish a draft from a Blog
         * @summary Publish Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsIdPublish(blogId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsIdPublish(blogId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates blog associations
         * @summary Update blog associations
         * @param {string} blogId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogAssociations(blogId: string, inlineObject24?: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogAssociations(blogId, inlineObject24, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this blog.
         * @summary Update Blog attributes
         * @param {string} blogId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogAttributes(blogId: string, inlineObject20?: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogAttributes(blogId, inlineObject20, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync blog categories
         * @summary Update Blog categories
         * @param {string} blogId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogCategories(blogId: string, inlineObject22?: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogCategories(blogId, inlineObject22, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync blog Channels
         * @summary Update Blog channels
         * @param {string} blogId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogChannels(blogId: string, inlineObject23?: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogChannels(blogId, inlineObject23, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a blogs customer groups
         * @summary Update customer groups
         * @param {string} blogId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogCustomerGroups(blogId: string, inlineObject25?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogCustomerGroups(blogId, inlineObject25, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a blogs collections.
         * @summary Update Blog collections
         * @param {string} blogId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogIdCollections(blogId: string, inlineObject21?: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogIdCollections(blogId, inlineObject21, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
         * @summary Duplicate Blog
         * @param {string} blogId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBlogsBlogIdDuplicate(blogId: string, inlineObject17?: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).postBlogsBlogIdDuplicate(blogId, inlineObject17, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a blog by it\'s ID
         * @summary Update Blog
         * @param {string} blogId
         * @param {BlogUpdateBody} [blogUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBlogsBlogId(blogId: string, blogUpdateBody?: BlogUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlogResponse>> {
            const localVarAxiosArgs = await BlogsApiAxiosParamCreator(configuration).putBlogsBlogId(blogId, blogUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BlogsApi - factory interface
 * @export
 */
export const BlogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detaches a category from a blog. Does not delete the category.
         * @summary Detach category
         * @param {string} blogId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCategoriesCategory(blogId: string, categoryId: string, options?: any): AxiosPromise<void> {
            return BlogsApiFp(configuration).deleteBlogsBlogCategoriesCategory(blogId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a collection from a blog. Does not delete the collection.
         * @summary Detach collection
         * @param {string} blogId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCollectionsDetach(blogId: string, collectionId: string, options?: any): AxiosPromise<void> {
            return BlogsApiFp(configuration).deleteBlogsBlogCollectionsDetach(blogId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches customer groups from a blog
         * @summary Detach customer groups
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogCustomerGroups(blogId: string, options?: any): AxiosPromise<void> {
            return BlogsApiFp(configuration).deleteBlogsBlogCustomerGroups(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
         * @summary Delete Blog
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogId(blogId: string, options?: any): AxiosPromise<void> {
            return BlogsApiFp(configuration).deleteBlogsBlogId(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes blog associations
         * @summary
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlogsBlogIdAssociations(blogId: string, options?: any): AxiosPromise<void> {
            return BlogsApiFp(configuration).deleteBlogsBlogIdAssociations(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of blogs.
         * @summary Get Blogs
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogs(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any): AxiosPromise<BlogCollection> {
            return BlogsApiFp(configuration).getBlogs(include, paginated, ids, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a blog by it\'s given ID
         * @summary Get Blog
         * @param {string} blogId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogId(blogId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsBlogIdDrafts(blogId: string, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).getBlogsBlogIdDrafts(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
         * @summary Get recommended blogs
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlogsRecommended(basketId: string, options?: any): AxiosPromise<BlogRecommendationCollection> {
            return BlogsApiFp(configuration).getBlogsRecommended(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog redirect
         * @param {string} blogId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogRedirects(blogId: string, inlineObject19?: InlineObject19, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogRedirects(blogId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new blog route.
         * @summary Create Blog route
         * @param {string} blogId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogUrls(blogId: string, inlineObject18?: InlineObject18, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogUrls(blogId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Blog
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogs(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogs(name, url, stock, familyId, price, sku, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft blog from an existing blog.
         * @summary Create Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdDrafts(blogId: string, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsIdDrafts(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a draft from a Blog
         * @summary Publish Draft
         * @param {string} blogId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsIdPublish(blogId: string, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsIdPublish(blogId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates blog associations
         * @summary Update blog associations
         * @param {string} blogId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAssociations(blogId: string, inlineObject24?: InlineObject24, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogAssociations(blogId, inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this blog.
         * @summary Update Blog attributes
         * @param {string} blogId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogAttributes(blogId: string, inlineObject20?: InlineObject20, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogAttributes(blogId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync blog categories
         * @summary Update Blog categories
         * @param {string} blogId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCategories(blogId: string, inlineObject22?: InlineObject22, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogCategories(blogId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync blog Channels
         * @summary Update Blog channels
         * @param {string} blogId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogChannels(blogId: string, inlineObject23?: InlineObject23, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogChannels(blogId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a blogs customer groups
         * @summary Update customer groups
         * @param {string} blogId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogCustomerGroups(blogId: string, inlineObject25?: InlineObject25, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogCustomerGroups(blogId, inlineObject25, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a blogs collections.
         * @summary Update Blog collections
         * @param {string} blogId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdCollections(blogId: string, inlineObject21?: InlineObject21, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogIdCollections(blogId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
         * @summary Duplicate Blog
         * @param {string} blogId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBlogsBlogIdDuplicate(blogId: string, inlineObject17?: InlineObject17, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).postBlogsBlogIdDuplicate(blogId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a blog by it\'s ID
         * @summary Update Blog
         * @param {string} blogId
         * @param {BlogUpdateBody} [blogUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBlogsBlogId(blogId: string, blogUpdateBody?: BlogUpdateBody, options?: any): AxiosPromise<BlogResponse> {
            return BlogsApiFp(configuration).putBlogsBlogId(blogId, blogUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlogsApi - object-oriented interface
 * @export
 * @class BlogsApi
 * @extends {BaseAPI}
 */
export class BlogsApi extends BaseAPI {
    /**
     * Detaches a category from a blog. Does not delete the category.
     * @summary Detach category
     * @param {string} blogId
     * @param {string} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public deleteBlogsBlogCategoriesCategory(blogId: string, categoryId: string, options?: any) {
        return BlogsApiFp(this.configuration).deleteBlogsBlogCategoriesCategory(blogId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches a collection from a blog. Does not delete the collection.
     * @summary Detach collection
     * @param {string} blogId
     * @param {string} collectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public deleteBlogsBlogCollectionsDetach(blogId: string, collectionId: string, options?: any) {
        return BlogsApiFp(this.configuration).deleteBlogsBlogCollectionsDetach(blogId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches customer groups from a blog
     * @summary Detach customer groups
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public deleteBlogsBlogCustomerGroups(blogId: string, options?: any) {
        return BlogsApiFp(this.configuration).deleteBlogsBlogCustomerGroups(blogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a blog by it\'s ID  > This will only soft delete the blog. It will then be available to restore at a later time.
     * @summary Delete Blog
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public deleteBlogsBlogId(blogId: string, options?: any) {
        return BlogsApiFp(this.configuration).deleteBlogsBlogId(blogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes blog associations
     * @summary
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public deleteBlogsBlogIdAssociations(blogId: string, options?: any) {
        return BlogsApiFp(this.configuration).deleteBlogsBlogIdAssociations(blogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of blogs.
     * @summary Get Blogs
     * @param {string} [include]
     * @param {boolean} [paginated]
     * @param {string} [ids] Return only the selected IDs
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public getBlogs(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any) {
        return BlogsApiFp(this.configuration).getBlogs(include, paginated, ids, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a blog by it\'s given ID
     * @summary Get Blog
     * @param {string} blogId
     * @param {string} [include]
     * @param {string} [exclTax] Prices shouldn\&#39;t include tax
     * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
     * @param {string} [optionData] Include option data
     * @param {string} [draft] Show draft if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public getBlogsBlogId(blogId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any) {
        return BlogsApiFp(this.configuration).getBlogsBlogId(blogId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft for a blog.  If a draft already exists, that current draft will be returned.
     * @summary Create draft
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public getBlogsBlogIdDrafts(blogId: string, options?: any) {
        return BlogsApiFp(this.configuration).getBlogsBlogIdDrafts(blogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return recommended blogs based on a basket.  Using blog associations, the API will find blogs in the basket and display any relations that have been defined.
     * @summary Get recommended blogs
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public getBlogsRecommended(basketId: string, options?: any) {
        return BlogsApiFp(this.configuration).getBlogsRecommended(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and syncs a new blog route.
     * @summary Create Blog redirect
     * @param {string} blogId
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogRedirects(blogId: string, inlineObject19?: InlineObject19, options?: any) {
        return BlogsApiFp(this.configuration).postBlogRedirects(blogId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and syncs a new blog route.
     * @summary Create Blog route
     * @param {string} blogId
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogUrls(blogId: string, inlineObject18?: InlineObject18, options?: any) {
        return BlogsApiFp(this.configuration).postBlogUrls(blogId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create Blog
     * @param {ShippingShippingMethodIdName} name
     * @param {string} url
     * @param {number} stock
     * @param {string} familyId
     * @param {number} price
     * @param {string} sku
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogs(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any) {
        return BlogsApiFp(this.configuration).postBlogs(name, url, stock, familyId, price, sku, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft blog from an existing blog.
     * @summary Create Draft
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsIdDrafts(blogId: string, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsIdDrafts(blogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish a draft from a Blog
     * @summary Publish Draft
     * @param {string} blogId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsIdPublish(blogId: string, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsIdPublish(blogId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates blog associations
     * @summary Update blog associations
     * @param {string} blogId
     * @param {InlineObject24} [inlineObject24]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogAssociations(blogId: string, inlineObject24?: InlineObject24, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogAssociations(blogId, inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to sync up the attributes which are directly associated to this blog.
     * @summary Update Blog attributes
     * @param {string} blogId
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogAttributes(blogId: string, inlineObject20?: InlineObject20, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogAttributes(blogId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync blog categories
     * @summary Update Blog categories
     * @param {string} blogId
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogCategories(blogId: string, inlineObject22?: InlineObject22, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogCategories(blogId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync blog Channels
     * @summary Update Blog channels
     * @param {string} blogId
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogChannels(blogId: string, inlineObject23?: InlineObject23, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogChannels(blogId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a blogs customer groups
     * @summary Update customer groups
     * @param {string} blogId
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogCustomerGroups(blogId: string, inlineObject25?: InlineObject25, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogCustomerGroups(blogId, inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a blogs collections.
     * @summary Update Blog collections
     * @param {string} blogId
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogIdCollections(blogId: string, inlineObject21?: InlineObject21, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogIdCollections(blogId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicates a blog, requires you to specify new slugs and SKU\'s.  > Duplicated blog will not immediately be active.
     * @summary Duplicate Blog
     * @param {string} blogId
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public postBlogsBlogIdDuplicate(blogId: string, inlineObject17?: InlineObject17, options?: any) {
        return BlogsApiFp(this.configuration).postBlogsBlogIdDuplicate(blogId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a blog by it\'s ID
     * @summary Update Blog
     * @param {string} blogId
     * @param {BlogUpdateBody} [blogUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlogsApi
     */
    public putBlogsBlogId(blogId: string, blogUpdateBody?: BlogUpdateBody, options?: any) {
        return BlogsApiFp(this.configuration).putBlogsBlogId(blogId, blogUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

}
