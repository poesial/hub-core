// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 0.12.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddBasketMetaBody } from '../models';
// @ts-ignore
import { ApiError } from '../models';
// @ts-ignore
import { BasketCollection } from '../models';
// @ts-ignore
import { BasketLineUpdateBody } from '../models';
// @ts-ignore
import { BasketResponse } from '../models';
// @ts-ignore
import { CreateBasketBody } from '../models';
// @ts-ignore
import { CreateBasketLinesBody } from '../models';
// @ts-ignore
import { InlineResponse200 } from '../models';
// @ts-ignore
import { SaveBasketBody } from '../models';
// @ts-ignore
import { SavedBasketCollection } from '../models';
// @ts-ignore
import { SavedBasketResponse } from '../models';
// @ts-ignore
import { Unauthenticated } from '../models';
/**
 * BasketsApi - axios parameter creator
 * @export
 */
export const BasketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/basket-lines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling deleteBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
         * @summary Remove discount
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling deleteBasketsBasketIdDiscounts.');
            }
            const localVarPath = `/baskets/{basketId}/discounts`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling getBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets/current`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets/saved`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines: async (createBasketLinesBody?: CreateBasketLinesBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/basket-lines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBasketLinesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBasketLinesBody !== undefined ? createBasketLinesBody : {}) : (createBasketLinesBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create Basket
         * @param {CreateBasketBody} [createBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBaskets: async (createBasketBody?: CreateBasketBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBasketBody !== undefined ? createBasketBody : {}) : (createBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A user is able to \"claim\" a guest basket.
         * @summary Allow a user to claim a basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling postBasketsBasketIdClaim.');
            }
            const localVarPath = `/baskets/{basketId}/claim`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId
         * @param {AddBasketMetaBody} [addBasketMetaBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta: async (basketId: string, addBasketMetaBody?: AddBasketMetaBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling postBasketsBasketIdMeta.');
            }
            const localVarPath = `/baskets/{basketId}/meta`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof addBasketMetaBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addBasketMetaBody !== undefined ? addBasketMetaBody : {}) : (addBasketMetaBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave: async (basketId: string, saveBasketBody?: SaveBasketBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling postBasketsBasketIdSave.');
            }
            const localVarPath = `/baskets/{basketId}/save`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve: async (saveBasketBody?: SaveBasketBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets/resolve`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId: async (basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new RequiredError('basketLineId','Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineId.');
            }
            const localVarPath = `/basket-lines/{basketLineId}`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd: async (basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new RequiredError('basketLineId','Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineIdAdd.');
            }
            const localVarPath = `/basket-lines/{basketLineId}/add`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove: async (basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new RequiredError('basketLineId','Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineIdRemove.');
            }
            const localVarPath = `/basket-lines/{basketLineId}/remove`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling putBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId: async (basketId: string, saveBasketBody?: SaveBasketBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling putBasketsSavedBasketId.');
            }
            const localVarPath = `/baskets/saved/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasketsApi - functional programming interface
 * @export
 */
export const BasketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBasketLines(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).deleteBasketLines(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBasketsBasketId(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).deleteBasketsBasketId(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
         * @summary Remove discount
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBasketsBasketIdDiscounts(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).deleteBasketsBasketIdDiscounts(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBaskets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketCollection>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBaskets(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketsBasketId(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBasketsBasketId(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketsCurrent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBasketsCurrent(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketsSaved(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedBasketCollection>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBasketsSaved(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketLines(createBasketLinesBody?: CreateBasketLinesBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketLines(createBasketLinesBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         *
         * @summary Create Basket
         * @param {CreateBasketBody} [createBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBaskets(createBasketBody?: CreateBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBaskets(createBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A user is able to \"claim\" a guest basket.
         * @summary Allow a user to claim a basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsBasketIdClaim(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdClaim(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId
         * @param {AddBasketMetaBody} [addBasketMetaBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsBasketIdMeta(basketId: string, addBasketMetaBody?: AddBasketMetaBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsBasketIdSave(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsResolve(saveBasketBody?: SaveBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsResolve(saveBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketLinesBasketLineId(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketLinesBasketLineIdAdd(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketLinesBasketLineIdRemove(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketsBasketId(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketsBasketId(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketsSavedBasketId(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedBasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BasketsApi - factory interface
 * @export
 */
export const BasketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines(options?: any): AxiosPromise<InlineResponse200> {
            return BasketsApiFp(configuration).deleteBasketLines(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId(basketId: string, options?: any): AxiosPromise<void> {
            return BasketsApiFp(configuration).deleteBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
         * @summary Remove discount
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts(basketId: string, options?: any): AxiosPromise<void> {
            return BasketsApiFp(configuration).deleteBasketsBasketIdDiscounts(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets(options?: any): AxiosPromise<BasketCollection> {
            return BasketsApiFp(configuration).getBaskets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId(basketId: string, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).getBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent(options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).getBasketsCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved(options?: any): AxiosPromise<SavedBasketCollection> {
            return BasketsApiFp(configuration).getBasketsSaved(options).then((request) => request(axios, basePath));
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines(createBasketLinesBody?: CreateBasketLinesBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketLines(createBasketLinesBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Basket
         * @param {CreateBasketBody} [createBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBaskets(createBasketBody?: CreateBasketBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBaskets(createBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A user is able to \"claim\" a guest basket.
         * @summary Allow a user to claim a basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim(basketId: string, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsBasketIdClaim(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId
         * @param {AddBasketMetaBody} [addBasketMetaBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta(basketId: string, addBasketMetaBody?: AddBasketMetaBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve(saveBasketBody?: SaveBasketBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsResolve(saveBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId(basketId: string, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): AxiosPromise<SavedBasketResponse> {
            return BasketsApiFp(configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasketsApi - object-oriented interface
 * @export
 * @class BasketsApi
 * @extends {BaseAPI}
 */
export class BasketsApi extends BaseAPI {
    /**
     * Removes basket lines from a basket
     * @summary Delete basket lines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public deleteBasketLines(options?: any) {
        return BasketsApiFp(this.configuration).deleteBasketLines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a basket
     * @summary Delete a basket by ID
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public deleteBasketsBasketId(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).deleteBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
     * @summary Remove discount
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public deleteBasketsBasketIdDiscounts(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).deleteBasketsBasketIdDiscounts(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of baskets
     * @summary Get baskets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBaskets(options?: any) {
        return BasketsApiFp(this.configuration).getBaskets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a basket by it\'s ID
     * @summary Get basket
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBasketsBasketId(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).getBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will get the current active basket for a user
     * @summary Get the current basket for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBasketsCurrent(options?: any) {
        return BasketsApiFp(this.configuration).getBasketsCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an authenticatd users saved baskets.
     * @summary Get a users saved baskets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBasketsSaved(options?: any) {
        return BasketsApiFp(this.configuration).getBasketsSaved(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add lines to a basket
     * @summary Create basket lines
     * @param {CreateBasketLinesBody} [createBasketLinesBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketLines(createBasketLinesBody?: CreateBasketLinesBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketLines(createBasketLinesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create Basket
     * @param {CreateBasketBody} [createBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBaskets(createBasketBody?: CreateBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).postBaskets(createBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A user is able to \"claim\" a guest basket.
     * @summary Allow a user to claim a basket
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsBasketIdClaim(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsBasketIdClaim(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to add custom meta information to a basket.
     * @summary Add meta information
     * @param {string} basketId
     * @param {AddBasketMetaBody} [addBasketMetaBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsBasketIdMeta(basketId: string, addBasketMetaBody?: AddBasketMetaBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves a basket to a users account.
     * @summary Save a basket for a user
     * @param {string} basketId
     * @param {SaveBasketBody} [saveBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsBasketIdSave(basketId: string, saveBasketBody?: SaveBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
     * @summary Resolve a basket
     * @param {SaveBasketBody} [saveBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsResolve(saveBasketBody?: SaveBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsResolve(saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a basket line based on it\'s ID.
     * @summary Update basket line
     * @param {string} basketLineId
     * @param {BasketLineUpdateBody} [basketLineUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketLinesBasketLineId(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update basket line quantity
     * @summary Update basket line quantity
     * @param {string} basketLineId
     * @param {BasketLineUpdateBody} [basketLineUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketLinesBasketLineIdAdd(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes quantity from a basket line
     * @summary Remove basket line quantity
     * @param {string} basketLineId
     * @param {BasketLineUpdateBody} [basketLineUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketLinesBasketLineIdRemove(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a basket
     * @summary Update a basket by ID
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketsBasketId(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).putBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a saved basket on the API
     * @summary Update a saved basket
     * @param {string} basketId
     * @param {SaveBasketBody} [saveBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketsSavedBasketId(basketId: string, saveBasketBody?: SaveBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

}
